<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lord Anwith - Wood Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    /* 1. Mobile Optimization */
    body { 
      margin: 0; 
      height: 100vh; 
      width: 100vw;
      overflow: hidden; 
      background: #2d1e12; 
      font-family: system-ui, -apple-system, sans-serif;
      touch-action: none; 
      -webkit-user-select: none; 
      user-select: none;
    }

    canvas { 
      display: block; 
      margin: auto; 
      /* We remove width/height here because JS handles it for sharpness */
      touch-action: none;
    }

    #ui-layer {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; 
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20; 
      transition: opacity 0.3s; 
    }

    #start-msg {
      text-align: center;
      color: #fff;
      text-shadow: 0 4px 15px rgba(0,0,0,0.9);
      animation: float 3s ease-in-out infinite;
    }

    h1 {
      font-size: 3rem;
      margin: 0;
      font-weight: 800;
      background: -webkit-linear-gradient(#fff, #ffc107);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 4px 4px rgba(0,0,0,0.8));
    }

    p {
      font-size: 1.2rem;
      margin-top: 10px;
      font-weight: 700;
      color: #ffca28; 
      text-shadow: 0 2px 4px rgba(0,0,0,1);
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    #debug {
      position: fixed; bottom: 10px; left: 10px; 
      color: rgba(255,255,255,0.5); 
      font-family: monospace; font-size: 10px; 
      pointer-events: none;
      z-index: 5;
    }
  </style>
</head>
<body>

  <div id="ui-layer">
    <div id="start-msg">
      <h1>LORD ANWITH</h1>
      <p>Tap Screen to Start</p>
      <p style="font-size: 0.9rem; color: #fff; margin-top:20px; opacity:0.8">Target: 10 Points</p>
    </div>
  </div>

  <div id="debug"></div>
  <canvas id="game"></canvas>

  <script>
    const c = document.getElementById('game');
    const ctx = c.getContext('2d');
    const uiLayer = document.getElementById('ui-layer');
    const debugDiv = document.getElementById('debug');

    // --- ASSETS ---
    const playerImg = new Image();
    playerImg.src = "assets/anwi13.jpg"; 

    // *** BACKGROUND IMAGE ***
    const bgImg = new Image();
    bgImg.src = "assets/wood.jpg"; 

    // SOUNDS
    const failAudio = new Audio();
    failAudio.src = "assets/ad1.mp3"; 
    
    const winAudio = new Audio();
    winAudio.src = "assets/jump2.mp3"; 
    
    const jumpAudio = new Audio();
    jumpAudio.src = "assets/jump.mp3"; 
    
    const winImg = new Image();
    winImg.src = "assets/kaup.jpg"; 

    // --- HIGH-DPI RESIZE FIX ---
    let gameW, gameH; // We use these instead of c.width/c.height in logic

    function resize() {
      // 1. Get the screen's pixel density (usually 2 or 3 on mobile)
      const dpr = window.devicePixelRatio || 1;
      
      // 2. Calculate the Logical Size (CSS Size)
      gameW = Math.min(window.innerWidth, 600);
      gameH = window.innerHeight;

      // 3. Set the Internal Resolution to High Quality
      c.width = gameW * dpr;
      c.height = gameH * dpr;

      // 4. Force the CSS Size to stay normal
      c.style.width = gameW + "px";
      c.style.height = gameH + "px";

      // 5. Scale the drawing context so logic coordinates don't break
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resize);
    resize();

    // Config
    const WIN_SCORE = 10; 

    // Game state
    const state = {
      running: false, 
      gameStarted: false,
      won: false,
      gravity: 0.55,
      jumpPower: -9.5,
      // Use gameH instead of c.height for logic
      player: { x: 60, y: 0, w: 70, h: 70, vy: 0, angle: 0 }, 
      walls: [],
      particles: [],
      score: 0,
      spawnTimer: 0,
      bgX: 0,
      bgSpeed: 1.5 
    };
    
    // Initialize player position based on new gameH
    state.player.y = gameH / 2;

    let audioUnlocked = false;

    // --- AUDIO HELPER ---
    function tryUnlockAudio() {
      if (audioUnlocked) return;
      try {
        [failAudio, winAudio, jumpAudio].forEach(snd => {
            const p = snd.play();
            if (p !== undefined) {
                p.then(() => { snd.pause(); snd.currentTime = 0; }).catch(e => {});
            }
        });
        audioUnlocked = true;
      } catch (e) {}
    }

    // --- CONTROLS ---
    function jump() {
      if (!state.gameStarted) {
        state.gameStarted = true;
        state.running = true;
        uiLayer.style.display = 'none';
        state.player.vy = state.jumpPower;
        tryUnlockAudio();
        playJumpSound();
        return;
      }

      if (!state.running || state.won) {
        reset();
        return;
      }

      if (state.running && !state.won) {
        state.player.vy = state.jumpPower;
        state.player.angle = -0.4;
        createParticles(state.player.x, state.player.y + state.player.h);
        playJumpSound();
      }
    }

    function playJumpSound() {
        jumpAudio.currentTime = 0;
        jumpAudio.play().catch(e => {});
    }

    c.addEventListener('mousedown', jump);
    c.addEventListener('touchstart', (e) => { e.preventDefault(); jump(); }, { passive: false });

    function reset() {
      failAudio.pause(); failAudio.currentTime = 0;
      winAudio.pause();  winAudio.currentTime = 0;
      jumpAudio.pause(); jumpAudio.currentTime = 0;

      state.running = true;
      state.won = false;
      state.player.y = gameH / 2;
      state.player.x = 60; 
      state.player.vy = 0;
      state.player.angle = 0;
      state.walls = [];
      state.particles = [];
      state.score = 0;
      state.spawnTimer = 0;
      uiLayer.style.display = 'none'; 
    }

    // --- LOOP ---
    function loop() {
      requestAnimationFrame(loop);
      // Clear using logical coordinates
      ctx.clearRect(0, 0, gameW, gameH);

      // 1. Draw Wood Background
      drawBackground();

      if (!state.gameStarted) {
         // Darken bg for intro
         ctx.fillStyle = "rgba(0,0,0,0.5)";
         ctx.fillRect(0, 0, gameW, gameH);
         drawPlayer();
         return;
      }

      if (state.won) {
        drawWinScene();
        return;
      }

      if (!state.running) {
        drawOverlay();
        return;
      }

      // Physics
      state.spawnTimer++;
      if (state.spawnTimer > 110 && !state.won) {
        spawnWall();
        state.spawnTimer = 0;
      }

      state.player.vy += state.gravity;
      state.player.y += state.player.vy;
      state.player.angle += 0.03;

      if (state.player.y + state.player.h > gameH || state.player.y < 0) {
        die();
      }

      state.walls.forEach(w => w.x += w.vx);
      state.walls = state.walls.filter(w => w.x + w.w > -100);

      for (const w of state.walls) {
        if (rectsOverlap(state.player, w)) die();
      }

      state.score++;
      let points = Math.floor(state.score / 100); 
      if (points >= WIN_SCORE) triggerWin();

      drawWalls();
      drawParticles();
      drawPlayer();
      drawScore(points);
    }

    // --- DRAWING FUNCTIONS ---
    
    function drawBackground() {
        if (state.running && !state.won) {
            state.bgX -= state.bgSpeed;
            if (state.bgX <= -gameW) state.bgX = 0;
        }
        
        if (bgImg.complete) {
            // Draw image twice to scroll it
            ctx.filter = "brightness(0.7)"; 
            ctx.drawImage(bgImg, state.bgX, 0, gameW, gameH);
            ctx.drawImage(bgImg, state.bgX + gameW, 0, gameW, gameH);
            ctx.filter = "none"; 
        } else {
            // Fallback brown
            ctx.fillStyle = "#3e2723";
            ctx.fillRect(0, 0, gameW, gameH);
        }
    }

    function spawnWall() {
      const gap = 175;
      const thickness = 55;
      const speed = 5;
      const gapY = Math.random() * (gameH - gap - 100) + 50;
      state.walls.push({ x: gameW, y: 0, w: thickness, h: gapY, vx: -speed });
      state.walls.push({ x: gameW, y: gapY + gap, w: thickness, h: gameH - (gapY + gap), vx: -speed });
    }

    function createParticles(x, y) {
      for(let i=0; i<5; i++) {
        state.particles.push({
          x: x + Math.random()*40,
          y: y,
          vx: (Math.random() - 0.5) * 2,
          vy: Math.random() * 2,
          life: 1.0,
          color: `rgba(222, 184, 135, ${Math.random()})` 
        });
      }
    }

    function rectsOverlap(a, b) {
      const pad = 12;
      return a.x + pad < b.x + b.w && a.x + a.w - pad > b.x &&
             a.y + pad < b.y + b.h && a.y + a.h - pad > b.y;
    }

    function drawWalls() {
      ctx.shadowBlur = 0;
      for (const w of state.walls) {
        ctx.fillStyle = "#3E2723"; 
        ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.lineWidth = 3;
        ctx.strokeStyle = "#8D6E63"; 
        ctx.strokeRect(w.x, w.y, w.w, w.h);
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(w.x + 5, w.y + 5, w.w - 10, w.h - 10);
      }
    }

    function drawParticles() {
      for (let i = state.particles.length - 1; i >= 0; i--) {
        let p = state.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        if(p.life <= 0) state.particles.splice(i, 1);
        else {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
      }
    }

    function drawScore(points) {
      ctx.fillStyle = "rgba(40, 30, 20, 0.7)"; 
      ctx.beginPath();
      if (ctx.roundRect) ctx.roundRect(15, 15, 140, 50, 10);
      else ctx.rect(15, 15, 140, 50);
      ctx.fill();
      
      ctx.strokeStyle = "#FFC107";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = "#fff";
      ctx.font = "800 24px sans-serif";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(points + " / " + WIN_SCORE, 35, 42);
    }

    function drawPlayer() {
      ctx.save();
      ctx.translate(state.player.x + state.player.w/2, state.player.y + state.player.h/2);
      ctx.rotate(state.player.angle);
      // Glow
      ctx.shadowColor = "rgba(0,0,0,0.8)";
      ctx.shadowBlur = 15;
      if (playerImg.complete) {
        ctx.beginPath();
        ctx.arc(0, 0, state.player.w/2, 0, Math.PI*2);
        ctx.clip();
        ctx.drawImage(playerImg, -state.player.w/2, -state.player.h/2, state.player.w, state.player.h);
        ctx.beginPath();
        ctx.arc(0, 0, state.player.w/2, 0, Math.PI*2);
        ctx.strokeStyle = "#FFD700"; 
        ctx.lineWidth = 3;
        ctx.stroke();
      } else {
        ctx.fillStyle = "#ff4757";
        ctx.beginPath();
        ctx.arc(0, 0, state.player.w/2, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawOverlay() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
        ctx.fillRect(0, 0, gameW, gameH);
        
        ctx.fillStyle = "#ff5252";
        ctx.font = "900 48px sans-serif";
        ctx.textAlign = "center";
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 20;
        ctx.fillText("CRASHED", gameW/2, gameH/2 - 20);
        
        ctx.shadowBlur = 0;
        ctx.fillStyle = "#fff";
        ctx.font = "300 18px sans-serif";
        ctx.fillText("Tap anywhere to retry", gameW/2, gameH/2 + 30);
    }

    function die() {
      state.running = false;
      failAudio.currentTime = 0; 
      failAudio.play().catch(e=>{});
    }

    function triggerWin() {
      state.won = true;
      state.walls = []; 
      winAudio.currentTime = 0; 
      winAudio.play().catch(e=>{});
    }

    function drawWinScene() {
      const targetX = gameW / 2 - 60;
      const targetY = gameH / 2;
      state.player.x += (targetX - state.player.x) * 0.05;
      state.player.y += (targetY - state.player.y) * 0.05;
      state.player.angle = 0;
      drawBackground(); 
      drawPlayer();
      const prizeX = gameW / 2 + 20;
      const prizeY = gameH / 2 - 40;
      const prizeSize = 80;
      ctx.save();
      ctx.shadowColor = "#FFD700";
      ctx.shadowBlur = 30;
      if (winImg.complete) {
        ctx.beginPath();
        ctx.arc(prizeX + prizeSize/2, prizeY + prizeSize/2, prizeSize/2, 0, Math.PI*2);
        ctx.clip();
        ctx.drawImage(winImg, prizeX, prizeY, prizeSize, prizeSize);
      } else {
        ctx.fillStyle = "gold";
        ctx.beginPath();
        ctx.arc(prizeX + prizeSize/2, prizeY + prizeSize/2, prizeSize/2, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
      
      ctx.fillStyle = "#FFD700"; 
      ctx.font = "900 40px sans-serif";
      ctx.textAlign = "center";
      ctx.shadowColor = "#FFD700";
      ctx.shadowBlur = 10;
      ctx.fillText("VICTORY!", gameW/2, gameH/2 - 100);
      
      ctx.shadowBlur = 0;
      ctx.fillStyle = "#fff";
      ctx.font = "300 18px sans-serif";
      ctx.fillText("Tap to Play Again", gameW/2, gameH/2 + 50);

      if (Math.abs(state.player.x - targetX) < 5) {
         ctx.font = "40px sans-serif";
         ctx.fillText("❤️", gameW/2, gameH/2 + 10);
      }
    }

    loop();
  </script>
</body>
</html>